import queue
import threading
from typing import Callable, Generic, Iterable, Iterator, Optional, TypeVar

In = TypeVar("In")
Out = TypeVar("Out")


class MultiThreadedNonBlockingIterable(
    Iterable[Out], Generic[In, Out]
):  # https://github.com/python/mypy/issues/2598
    """
    Non-blocking Iterable wrapper around an Iterable.
    This is useful when the iterator generated by the wrapped Iterable
    may block for arbitrarily large amounts of time waiting for data from
    an upstream dataset (example: a replay buffer) and we want to be able
    to do something else in the meantime.

    This non-blocking Iterable uses several threads in parallel to fetch
    the data from the input iterable. This enables us to fetch several
    items in advance and apply the collate function to them.
    """

    def __init__(
        self,
        iterable: Iterable[In],
        timeout: Optional[float] = None,
        collate_fn: Callable[[In], Out] = lambda x: x,
        num_threads: int = 2,
        queue_size: Optional[int] = None,
    ):
        if timeout is not None and timeout < 0.0:
            raise RuntimeError(f"timeout must be non-negative {timeout}")

        self._timeout = timeout
        self._iterable = iter(iterable)
        self._collate_fn = collate_fn
        self._num_threads = num_threads

        self._queue_size = queue_size if queue_size is not None else num_threads + 1
        self._queue = queue.Queue(maxsize=self._queue_size)

        self._lock = threading.Lock()

        self._thread_list = []
        for _ in range(num_threads):
            thread = threading.Thread(
                target=self._background_thread, args=(), daemon=True
            )
            thread.start()
            self._thread_list.append(thread)

    def __iter__(self) -> Iterator[Out]:
        stop_iteration_counter = 0

        while True:
            success, element = self._queue.get(timeout=self._timeout)
            if success:
                yield element
            else:
                stop_iteration_counter += 1

            if not success and stop_iteration_counter >= self._num_threads:
                for thread in self._thread_list:
                    thread.join()
                return

    def _background_thread(self) -> None:
        while True:
            try:
                with self._lock:
                    element = next(self._iterable)
                if self._collate_fn is not None:
                    self._queue.put((True, self._collate_fn(element)))
                else:
                    self._queue.put((True, element))
            except StopIteration:
                self._queue.put((False, None))
                return
